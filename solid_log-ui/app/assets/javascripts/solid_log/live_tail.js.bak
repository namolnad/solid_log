// Live Tail functionality for SolidLog streams
// Supports both WebSocket (ActionCable) and HTTP polling modes
(function() {
  let liveTailActive = false;
  let pollingInterval = null;
  let cableSubscription = null;
  let lastEntryId = null;
  let mode = null;

  function initializeLiveTail() {
    const toggleButton = document.getElementById('live-tail-toggle');
    if (!toggleButton) return;

    mode = toggleButton.dataset.liveTailMode;
    if (!mode || mode === 'disabled') return;

    toggleButton.addEventListener('click', function(e) {
      e.preventDefault();
      toggleLiveTail();
    });

    // Store last entry ID for tracking
    updateLastEntryId();
  }

  function toggleLiveTail() {
    liveTailActive = !liveTailActive;
    const button = document.getElementById('live-tail-toggle');

    if (liveTailActive) {
      startLiveTail();
      button.textContent = '⏸ Pause';
      button.classList.add('btn-primary');
      button.classList.remove('btn-secondary');

      // Show toast notification
      if (window.SolidLogToast) {
        window.SolidLogToast.show(`Live tail ${mode === 'websocket' ? 'streaming' : 'polling'} started`, 'info');
      }
    } else {
      stopLiveTail();
      button.textContent = '▶ Live Tail';
      button.classList.remove('btn-primary');
      button.classList.add('btn-secondary');

      if (window.SolidLogToast) {
        window.SolidLogToast.show('Live tail stopped', 'info');
      }
    }
  }

  function startLiveTail() {
    if (mode === 'websocket' && typeof createConsumer !== 'undefined') {
      startWebSocketTail();
    } else {
      // Fallback to polling if websocket unavailable or mode is 'polling'
      startPollingTail();
    }

    // Auto-scroll to bottom
    scrollToBottom();
  }

  function stopLiveTail() {
    if (cableSubscription) {
      cableSubscription.unsubscribe();
      cableSubscription = null;
    }

    if (pollingInterval) {
      clearInterval(pollingInterval);
      pollingInterval = null;
    }
  }

  function startWebSocketTail() {
    // Get current filter params
    const filters = getCurrentFilters();

    // Create ActionCable subscription
    const consumer = createConsumer();
    cableSubscription = consumer.subscriptions.create(
      {
        channel: "SolidLog::LogStreamChannel",
        filters: filters
      },
      {
        connected() {
          console.log('Connected to log stream');
        },

        disconnected() {
          console.log('Disconnected from log stream');

          // Reset button state to show stream has stopped
          resetLiveTailButton();

          // If still active, fallback to polling
          if (liveTailActive) {
            console.log('Falling back to polling mode');
            if (window.SolidLogToast) {
              window.SolidLogToast.show('Connection lost, switching to polling mode', 'warning');
            }
            startPollingTail();
          }
        },

        received(data) {
          // Received new log entry via websocket (already filtered server-side)
          if (data.html) {
            appendEntry(data.html);
            updateLastEntryId();
            scrollToBottom();
          }
        }
      }
    );
  }

  function startPollingTail() {
    // Poll every 2 seconds
    pollingInterval = setInterval(function() {
      fetchNewEntries();
    }, 2000);

    // Initial fetch
    fetchNewEntries();
  }

  function fetchNewEntries() {
    const streamsPath = document.body.dataset.streamsPath || '/streams';
    const url = new URL(window.location.origin + streamsPath);

    // Copy current filters
    const currentParams = new URLSearchParams(window.location.search);
    currentParams.forEach((value, key) => {
      url.searchParams.append(key, value);
    });

    // Add after_id parameter if we have a last entry
    if (lastEntryId) {
      url.searchParams.set('after_id', lastEntryId);
    }

    // Request turbo stream format
    fetch(url.toString(), {
      headers: {
        'Accept': 'text/vnd.turbo-stream.html',
        'X-Requested-With': 'XMLHttpRequest'
      }
    })
    .then(response => {
      if (!response.ok) throw new Error('Network response was not ok');
      return response.text();
    })
    .then(html => {
      if (html && html.trim()) {
        // Turbo will automatically process the stream response
        Turbo.renderStreamMessage(html);
        updateLastEntryId();
        scrollToBottom();
      }
    })
    .catch(error => {
      console.error('Error fetching new logs:', error);
    });
  }

  function appendEntry(html) {
    const logStream = document.getElementById('log-stream-content');
    if (!logStream) return;

    const temp = document.createElement('div');
    temp.innerHTML = html;

    // Append new entries
    while (temp.firstChild) {
      logStream.appendChild(temp.firstChild);
    }
  }

  function updateLastEntryId() {
    const logStream = document.getElementById('log-stream-content');
    if (!logStream) return;

    const entries = logStream.querySelectorAll('[data-entry-id]');
    if (entries.length > 0) {
      const lastEntry = entries[entries.length - 1];
      lastEntryId = lastEntry.dataset.entryId;
    }
  }

  function getCurrentFilters() {
    const filters = {};
    const params = new URLSearchParams(window.location.search);

    params.forEach((value, key) => {
      if (key.startsWith('filters[')) {
        const filterKey = key.match(/filters\[(.*?)\]/)[1];
        if (!filters[filterKey]) {
          filters[filterKey] = [];
        }
        filters[filterKey].push(value);
      }
    });

    return filters;
  }

  function entryMatchesFilters(entry) {
    const filters = getCurrentFilters();

    // If no filters, show all entries
    if (Object.keys(filters).length === 0) {
      return true;
    }

    // Check each filter
    for (const [key, values] of Object.entries(filters)) {
      if (!values || values.length === 0) continue;

      // Get the entry's value for this filter
      const entryValue = entry[key];
      if (!entryValue) {
        // If filter is set but entry doesn't have this field, exclude it
        return false;
      }

      // For array filters (levels, app, etc.), check if entry value is in the filter array
      if (Array.isArray(values)) {
        if (!values.includes(String(entryValue))) {
          return false;
        }
      } else {
        // For single value filters
        if (String(entryValue) !== String(values)) {
          return false;
        }
      }
    }

    return true;
  }

  function scrollToBottom() {
    setTimeout(() => {
      if (window.SolidLogStream && window.SolidLogStream.scrollToBottom) {
        window.SolidLogStream.scrollToBottom();
      } else {
        const streamsMain = document.querySelector('.streams-main');
        if (streamsMain) {
          streamsMain.scrollTop = streamsMain.scrollHeight;
        }
      }
    }, 50);
  }

  // Initialize on page load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initializeLiveTail);
  } else {
    initializeLiveTail();
  }

  // Re-initialize on turbo navigation
  document.addEventListener('turbo:load', initializeLiveTail);

  // Clean up on page unload
  window.addEventListener('beforeunload', stopLiveTail);
})();
